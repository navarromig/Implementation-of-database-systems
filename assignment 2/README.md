ΚΩΝΣΤΑΝΤΙΝΟΣ ΜΥΡΤΟΛΛΑΡΗ - 1115202000148 
ΜΙΧΑΗΛ ΧΡΗΣΤΟΣ ΝΑΒΑΡΟ ΑΜΑΡΓΙΑΝΟΣ - 1115202000151



- ΕΡΓΑΣΙΑ 1

Γενικές λεπτομέρειες:

- H OpenFile μεταφέρει στον ενταμιευτή το block 0 και επιστρέφει δείκτη στο αντίστοιχο struct info (HP_info/HT_info). Το block αυτό δεν γίνεται Unpinned, παρα μόνο στο τέλος από την Closefile, ώστε να παραμείνει έγκυρος ο δείκτης καθ'όλη την διάρκεια του προγράμματος. Σε περίπτωση τροποποίησης του block 0, τότε το θέτουμε Dirty.

- Για το γράψιμο των εγγραφών και των μεταδεδομένων στα blocks γίνεται χρήση της memcpy. Επιπλέον, για την ανάγνωση των εγγραφών και τον μεταδεδομένων κάνουμε cast, τους δείκτες στα δεδομένα των blocks, στους αντίστοιχους τύπους που μας ενδιαφέρουν. πχ. Record, Hp_block_info

- Το πεδίο next_block των struct block_info (HP_block_info/HT_block_info), λαμβάνει την τιμή -1 όταν το τρέχον block δεν δείχνει σε επόμενο

- Τα μεταδεδομένα των blocks τοποθετούνται στα τελευταία τους bytes.

- Υλοποιούνται δύο CALL_BF, η μια σε περίπτωση error επιστρέφει -1, ενώ η άλλη NULL.

- Η μεταβλητή type_file των struct HP_info/HT_info προσδιορίζει αν πρόκειται για αρχείο Σωρού ή Κατακερματισμού. Aρχικοποιείται από την CreateFile και χρησιμοποιείται για έλεγχο στην OpenFile.

-------------------------------------------------------

Υλοποίηση με Hash: 

- Το hash table αρχικοποιείται με -1. Για την εισαγωγή μιας εγγραφής, αν ο κάδος που της αντιστοιχεί έχει τιμή -1 στο hash table, τότε δεσμεύεται ένα νέο block, στο οποίο εισάγεται η εγγραφή και ενημερώνεται το hash table με το ID του block.

- Σε περίπτωση υπερχείλισης, το hash table ενημερώνεται με το ID του overflow block. Το overflow block δείχνει στο block από το οποίο προκλήθηκε η υπερχείληση, δηλαδή τοποθετείται στην αρχή της συνδεδεμένης λίστας, η οποία αποτελείται από τα blocks του κάδου. Έτσι, έχουμε πολύ καλύτερη πολυπλοκότητα στην InsertEntry από το αν το overflow block τοποθετούνταν στο τέλος της λίστας

-------------------------------------------------------

- Στο αρχείο src/stats.c περιλαμβάνεται η υλοποίηση της HashStatistics. Άδειοι κάδοι δεν λαμβάνονται υπόψιν στον υπολογισμό των στατιστικών (πχ ελάχιστο και μέσο πλήθος εγγραφών στους κάδους).

- Δίνεται το αρχείο example/ht_stats_main.c το οποίο εκτελείται με την εντολή ./build/ht_stats_main και μεταγλωτίζεται με την εντολή make ht_stats. 
Τρέχοντας το συγκεκριμένο παράδειγμα παρατηρείται ομοιομορφία ως προς την κατανονομή των εγγραφών και κατά συνέπεια των blocks στους κάδους. 

- Δίνεται επιπλεόν το αρχείο example/heap_vs_hash.c το οποίο εκφράζει καθαρά την υπεροχή του hashing ενάντι του heap. Για το ίδιο id στο heap διατρέχονται 1.667 blocks ενώ στο hashing μονάχα 167 blocks. Για την εκτέλεση του γίνεται χρήση της εντολής ./build/hp_vs_ht, ενώ μεταγλωτίζεται με την εντολή make hp_vs_ht.






- ΕΡΓΑΣΙΑ 2

Η υλοποίηση του δευτερευόντος ευρετηρίου στατικού κατακερματισμού σχεδόν ταυτίζεται με την υλοποίησή μας για το πρωτεύον ευρετήριο στατικού κατακερματισμού στην προηγούμενη εργασία. Θα αναλύσουμε τις όποιες διαφορές.

- Στο SHT_info περιλαμβάνεται ως πρόσθετη πληροφορία το όνομα του πρωτεύοντος ευρετηρίου στατικού κατακερματισμού

- Έχει οριστεί ένα struct SHT_Record που αποτελείται από ένα όνομα και έναν ακέραιο δεικτή στο block του πρωτεύοντος ευρετηρίου, στο οποίο έγινε η εισαγωγή της εγγραφής με το παραπάνω όνομα

- Η hash function που ορίζεται, επιστρέφει το υπόλοιπο της διαίρεσης του αθροίσματος των χαρακτήρων του ονόματος με των αριθμό των κάδων.

- Έχει οριστεί η συνάρτηση FindName που δεχόμενη ένα όνομα και ένα δείκτη σε block του πρωτεύοντος ευρετηρίου αναζητά εγγραφή με το ίδιο όνομα μέσα στο block. Καλείται από την SHT_SecondaryGetAllEntries

--------------------------------------------------------------------


- Δίνεται το αρχείο example/sht_main.c το οποίο εκτελείται με την εντολή ./build/sht_main και μεταγλωτίζεται με την εντολή make sht. Παρατηρείται πως διατρέχοντας μονάχα ένα block του δευτερευόντος ευρετηρίου, γίνεται δυνάτη η εύρεση όλων των Ιωσήφ και συνεπώς της εύρεσης των αντίστοιχων εγγραφών στο πρωτεύον ευρετήριο. Έτσι, γίνεται άμεσα εμφανής η αξία των δευτερευόντων ευρετηρίων, αφού στην περίπτωση ύπαρξης μόνο του πρωτεύοντος ευρετηρίου θα απαιτούνταν διάσχιση όλων των buckets κατ'επέκταση όλων των blocks του αρχείου.

- Δίνεται το αρχείο example/sht_stats_main.c, το οποίο εκτελείται με την εντολή ./build/sht_stats_main και μεταγλωτίζεται με την εντολή make sht_stats.Kαθώς οι εγγραφές είναι της μορφής <όνομα, δείκτης>, είναι δυνατόν σε ένα block να φιλοξενηθούν πολλές εγγραφές εξοικονομώντας χώρο σε blocks. Αυτό επιβεβαιώνεται και με το παραπάνω παράδειγμα, όπου για 102.560 εγγραφές χρησιμοποιούνται μονάχα 4.107 blocks στο αρχείο δευτερευόντος κατακερματισμού. Ώστοσο, παρατηρείται μεγάλος αριθμός overflow blocks, με τον μέσο όρο blocks ανά bucket να είναι ίσο με 684. Αυτό οφείλεται στο ότι γίνεται χρήση στατικού κατακερματισμού. Η χρήση περισσότερων buckets ή η υιοθετήση επεκτατού κατακερματισμού θα αποτελούσε λύση.



